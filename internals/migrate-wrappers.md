
[TODO] General context about what peeps is

We have a lot of wrappers to migrate from an old model to a new model. In the
old model, we had a database that we manually retrieved and locked(), so that we
could call specific methods on it to update the state of various things like
locks and channels and whatever.

In the new model, we have moved on to typed handlers for 4 kinds of things:

  * entities
  * events
  * scopes
  * edges
  
It's important to understand what is tracked as what. Let's take the example
of an MPSC channel. The two ends of the channel, the sender and the receiver,
are both modeled as entities.
 
Because those are two sides of a pair, there is an edge between them, of type
`PairedWith`.

```rust
// TODO: show EdgeKind
```

A future that was annotated and is tracked by peeps is also tracked as an
entity. When that feature tries to send something to that MPSC channel, there is
also an edge being created: It starts off as `Polls` and can be upgraded to
`WaitingOn`, if the send operation returned `PollPending`.

Previously, both the sender and the receiver of the MPSC channel attract a lot
of different internal atomic counters. Then we would call a method on the
database. It would read all of those counters and compare with the previous
value, check if anything has changed, create an event that this thing has
changed, which is important because we're essentially capturing the state of the
application over time, accumulating a list of changes, which lets us take
snapshots at any given time, which are then sent to a server, persisted as
SQLite, and then queried from a browser.

Now everything is handled through those typed handles like `EntityHandle`. has a
mutate method so whenever anything interesting happens with the entity and we
want to update one of its properties, like for example "We have buffered a new
entry inside of the sender of a buffered MPSC channel", and we want to increment
the `num_buffered` property, Then the sender type, which wraps the tokio sender
type, has the handle, and it calls mutate on that handle and passes a closure
that mutates that field. Transparently, the entity handle, which had a hash of
the entity body before and takes a hash of the entity after, knows if anything
changed, and if anything creates a change and records it to be persisted or
broadcasted:

```rust
// TODO: fill in pseudocode for mutate
```

Another thing that has changed is that we used to have arbitrary metadata on
entities, and this is gone. If we want to record something important, it's going
to be in the body of the entity.

Finally, we should talk about source, we used to have source as a compact string
and it was formatted `{source_file_path:line}`, and then a separate field that
was called `krate`. The changes here are we have a proper source type, which
unifies both those implementations. There's normalization going on under the
hood, but you don't need to care about that, because all of the constructors of
entities and edges and all the objects that we're tracking take an `impl
Into<SourceId>`.

This is because sources are now interned, but it doesn't really change much. The
important part is how sources are captured.

And we have a whole, essentially this is described in the documentation for the
peep source module, but basically we have `facade!` which expands to extension
traits, which expose `fn lock(&self) {}` and those internally call `fn
lock_with_source(&self, source: Source) {}`

`fn lock` is pub, `fn lock_with_source` _has_ to be pub, but it's doc(hidden).
Only the extension traits' methods generated by `facade!` have to be `#[track_caller]`.

As for the wrapper types (in `crates/peeps/src/enabled`):

  * they DOT NO have to annotate their methods with `#[track_caller]`
  * they CAN and SHOULD use `async fn` whenever convenient
