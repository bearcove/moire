# Storage And Ingest Spec

Status: todo
Owner: wg-storage-ingest
Scope: `crates/peeps-web`

## Goal

Persist synchronized multi-process snapshots keyed by `snapshot_id`.

## Ingest contract (v1)

`peeps-web` uses server-orchestrated pull snapshots:

- server sends dump request to each connected process with `snapshot_id`
- process returns framed `ProcessDump` tagged with same `snapshot_id`
- frame header: 4-byte big-endian unsigned length
- frame body: UTF-8 JSON `ProcessDump`

- frame header: 4-byte big-endian unsigned length
- frame body: UTF-8 JSON `ProcessDump`

Error handling:
- reject frames > configured max (default 128 MiB)
- invalid UTF-8: close connection with reason
- invalid JSON/shape: log + continue connection

## SQLite schema (v1)

```sql
CREATE TABLE nodes (
  snapshot_id INTEGER NOT NULL,
  id         TEXT    NOT NULL,
  kind       TEXT    NOT NULL,
  process    TEXT    NOT NULL,
  attrs_json TEXT    NOT NULL,
  PRIMARY KEY (snapshot_id, id)
);

CREATE TABLE edges (
  snapshot_id INTEGER NOT NULL,
  src_id     TEXT    NOT NULL,
  dst_id     TEXT    NOT NULL,
  kind       TEXT    NOT NULL,
  attrs_json TEXT    NOT NULL,
  PRIMARY KEY (snapshot_id, src_id, dst_id, kind)
);

CREATE TABLE snapshots (
  snapshot_id INTEGER PRIMARY KEY,
  requested_at_ns INTEGER NOT NULL,
  completed_at_ns INTEGER,
  timeout_ms INTEGER NOT NULL
);

CREATE TABLE snapshot_processes (
  snapshot_id INTEGER NOT NULL,
  process TEXT NOT NULL,
  pid INTEGER,
  status TEXT NOT NULL, -- responded|timeout|disconnected|error
  recv_at_ns INTEGER,
  error_text TEXT,
  PRIMARY KEY (snapshot_id, process)
);

CREATE INDEX idx_nodes_snapshot_kind    ON nodes(snapshot_id, kind);
CREATE INDEX idx_nodes_snapshot_process ON nodes(snapshot_id, process);
CREATE INDEX idx_edges_snapshot_src     ON edges(snapshot_id, src_id);
CREATE INDEX idx_edges_snapshot_dst     ON edges(snapshot_id, dst_id);
CREATE INDEX idx_edges_snapshot_kind    ON edges(snapshot_id, kind);
```

## Snapshot write semantics

- `snapshot_id` is monotonic and generated by server on `Jump to now`.
- Server requests dumps from all currently connected processes for that `snapshot_id`.
- Snapshot closes when timeout elapses or all processes respond.
- Writes are atomic per process payload (single transaction per process reply).
- `snapshot_processes.status` tracks missing/stale/non-responding processes.

## Required runtime settings

- WAL mode
- sane busy timeout
- single writer path (or write queue) to avoid lock contention

## Data retention policy (v1)

- Keep latest N snapshots (default N=500).
- Evict older snapshots with transactional delete:
  - delete from `edges` where `snapshot_id` < cutoff
  - delete from `nodes` where `snapshot_id` < cutoff
  - delete from `snapshot_processes` where `snapshot_id` < cutoff
  - delete from `snapshots` where `snapshot_id` < cutoff

## Acceptance criteria

1. `Jump to now` produces one synchronized `snapshot_id`.
2. Responding processes for that `snapshot_id` are persisted with explicit status rows.
3. Crash during ingest does not leave partial rows for a single process reply transaction.
